/**
 * Document Streaming Routes
 * 
 * This module handles real-time document creation with AI-generated content
 * streaming using Server-Sent Events (SSE).
 * 
 * Features:
 * - Creates document in database immediately
 * - Streams AI-generated summary character-by-character
 * - Generates flashcards after summary completes
 * - Sends real-time progress events to client
 * 
 * SSE Events:
 * - document-created: Initial document saved to database
 * - summary-start: AI summary generation begins
 * - summary-chunk: Each chunk of summary text as it's generated
 * - summary-complete: Full summary is ready
 * - flashcards-start: Flashcard generation begins
 * - flashcards-complete: All flashcards generated
 * - complete: Entire process finished
 * - error: Any error during the process
 * 
 * @requires Authentication - All routes protected by JWT
 */

import { Router } from 'express';
import { authenticateToken, AuthRequest } from '../lib/auth';
import { generateSummaryStream, generateFlashcards } from '../lib/ai';
import { supabase } from '../lib/supabase';
import cuid from 'cuid';

const router = Router();

/**
 * Authentication Middleware
 * All routes in this module require a valid JWT token
 */
router.use(authenticateToken);

/**
 * Create Document with Streaming AI Generation
 * POST /api/documents-stream/stream
 * 
 * This endpoint creates a document and streams AI-generated content in real-time.
 * The client receives Server-Sent Events (SSE) for each stage of processing.
 * 
 * Request Body:
 * @param {string} title - Document title
 * @param {string} content - Document content/text
 * 
 * SSE Event Flow:
 * 1. document-created - Document saved with ID
 * 2. summary-start - AI summary generation starting
 * 3. summary-chunk - Each piece of summary text (multiple events)
 * 4. summary-complete - Full summary ready
 * 5. flashcards-start - Flashcard generation starting
 * 6. flashcards-complete - All flashcards ready
 * 7. complete - Process finished successfully
 * 
 * @authentication Required - JWT token in Authorization header
 * @returns {EventStream} Server-Sent Events stream with progress updates
 */
router.post('/stream', async (req: AuthRequest, res) => {
  const { title, content } = req.body;
  const userId = req.user?.userId;

  console.log(`ðŸ“¥ POST /api/documents-stream/stream - Title: ${title}`);

  /**
   * Configure Server-Sent Events (SSE) Headers
   * These headers are required for SSE to work properly:
   * - Content-Type: text/event-stream tells browser this is an SSE connection
   * - Cache-Control: no-cache prevents caching of the stream
   * - Connection: keep-alive keeps the connection open for streaming
   */
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');
  res.flushHeaders(); // Send headers immediately

  try {
    /**
     * Step 1: Create Document in Database
     * Create the document record first with a unique ID,
     * then generate AI content asynchronously
     */
    const documentId = cuid();
    
    const { data: document, error: docError } = await supabase
      .from('documents')
      .insert({
        id: documentId,
        userId,
        title,
        content,
        summary: null,
        createdAt: new Date().toISOString(),
      })
      .select()
      .single();

    if (docError) throw docError;

    /**
     * Step 2: Notify Client - Document Created
     * Send SSE event with document ID so client can track the document
     */
    res.write(`event: document-created\n`);
    res.write(`data: ${JSON.stringify({ documentId, title })}\n\n`);

    /**
     * Step 3: Generate AI Summary with Streaming
     * Stream the summary character-by-character for real-time "typing" effect
     */
    res.write(`event: summary-start\n`);
    res.write(`data: {}\n\n`);

    let fullSummary = '';
    
    try {
      // Stream each chunk of text as it's generated by the AI
      for await (const chunk of generateSummaryStream(content)) {
        fullSummary += chunk;
        // Send each chunk to the client immediately
        res.write(`event: summary-chunk\n`);
        res.write(`data: ${JSON.stringify({ text: chunk })}\n\n`);
      }

      /**
       * Update database with the complete summary
       * This is done after streaming completes
       */
      await supabase
        .from('documents')
        .update({ summary: fullSummary.trim() })
        .eq('id', documentId);

      // Notify client that summary is complete
      res.write(`event: summary-complete\n`);
      res.write(`data: ${JSON.stringify({ summary: fullSummary.trim() })}\n\n`);
    } catch (aiError: any) {
      console.error('AI summary generation failed:', aiError.message);
      // Send error event but continue with flashcard generation
      res.write(`event: summary-error\n`);
      res.write(`data: ${JSON.stringify({ error: aiError.message })}\n\n`);
    }

    /**
     * Step 4: Generate Flashcards
     * Create educational flashcards from the document content
     */
    res.write(`event: flashcards-start\n`);
    res.write(`data: {}\n\n`);

    try {
      // Generate 3-5 flashcards using AI
      const flashcardData = await generateFlashcards(content);
      
      if (flashcardData && flashcardData.length > 0) {
        const flashcardsToInsert = flashcardData.map((fc: { question: string; answer: string }) => ({
          id: cuid(),
          documentId: documentId,
          question: fc.question,
          answer: fc.answer,
          createdAt: new Date().toISOString(),
        }));

        await supabase
          .from('flashcards')
          .insert(flashcardsToInsert);

        res.write(`event: flashcards-complete\n`);
        res.write(`data: ${JSON.stringify({ flashcards: flashcardData })}\n\n`);
      }
    } catch (aiError: any) {
      console.error('Flashcard generation failed:', aiError.message);
      res.write(`event: flashcards-error\n`);
      res.write(`data: ${JSON.stringify({ error: aiError.message })}\n\n`);
    }

    // Send completion event
    res.write(`event: complete\n`);
    res.write(`data: ${JSON.stringify({ documentId })}\n\n`);
    res.end();

  } catch (error: any) {
    console.error('Error creating document with streaming:', error);
    res.write(`event: error\n`);
    res.write(`data: ${JSON.stringify({ error: error.message })}\n\n`);
    res.end();
  }
});

export default router;
