/**
 * Documents API Tests
 * 
 * Tests for document CRUD operations
 */

import { mockPrismaClient } from './setup';

describe('Documents API', () => {
  const mockDocument = {
    id: '1',
    title: 'Test Document',
    content: 'This is test content for learning.',
    summary: 'Test summary generated by AI',
    userId: 'user-1',
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  const mockFlashcards = [
    {
      id: '1',
      question: 'What is this test?',
      answer: 'A unit test for documents',
      documentId: '1',
      easeFactor: 2.5,
      interval: 1,
      repetitions: 0,
      nextReview: new Date(),
      createdAt: new Date(),
      updatedAt: new Date(),
    },
  ];

  describe('POST /api/documents', () => {
    it('should create a document with AI summary and flashcards', async () => {
      mockPrismaClient.document.create.mockResolvedValue(mockDocument);
      mockPrismaClient.flashcard.createMany.mockResolvedValue({ count: 3 });

      expect(mockPrismaClient.document.create).toBeDefined();
    });

    it('should validate required fields', async () => {
      const invalidDoc = {
        // Missing title and content
        userId: 'user-1',
      };

      expect(invalidDoc.userId).toBeDefined();
    });
  });

  describe('GET /api/documents', () => {
    it('should return all user documents', async () => {
      mockPrismaClient.document.findMany.mockResolvedValue([mockDocument]);

      const documents = await mockPrismaClient.document.findMany({
        where: { userId: 'user-1' },
      });

      expect(documents).toHaveLength(1);
      expect(documents[0].title).toBe('Test Document');
    });

    it('should filter documents by user', async () => {
      mockPrismaClient.document.findMany.mockResolvedValue([mockDocument]);

      const documents = await mockPrismaClient.document.findMany({
        where: { userId: 'user-1' },
      });

      expect(documents.every((doc: typeof mockDocument) => doc.userId === 'user-1')).toBe(true);
    });
  });

  describe('GET /api/documents/:id', () => {
    it('should return document with flashcards', async () => {
      mockPrismaClient.document.findUnique.mockResolvedValue({
        ...mockDocument,
        flashcards: mockFlashcards,
      } as any);

      const document = await mockPrismaClient.document.findUnique({
        where: { id: '1' },
        include: { flashcards: true },
      });

      expect(document?.flashcards).toHaveLength(1);
    });

    it('should return 404 for non-existent document', async () => {
      mockPrismaClient.document.findUnique.mockResolvedValue(null);

      const document = await mockPrismaClient.document.findUnique({
        where: { id: 'non-existent' },
      });

      expect(document).toBeNull();
    });
  });

  describe('PUT /api/documents/:id', () => {
    it('should update document', async () => {
      const updatedDoc = {
        ...mockDocument,
        title: 'Updated Title',
        content: 'Updated content',
      };

      mockPrismaClient.document.update.mockResolvedValue(updatedDoc);

      const document = await mockPrismaClient.document.update({
        where: { id: '1' },
        data: { title: 'Updated Title', content: 'Updated content' },
      });

      expect(document.title).toBe('Updated Title');
    });
  });

  describe('DELETE /api/documents/:id', () => {
    it('should delete document', async () => {
      mockPrismaClient.document.delete.mockResolvedValue(mockDocument);

      const document = await mockPrismaClient.document.delete({
        where: { id: '1' },
      });

      expect(document.id).toBe('1');
    });
  });
});
